// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	onfido "bitbucket.org/junglee_games/getsetgo/onfido"
	mock "github.com/stretchr/testify/mock"
)

// Onfido is an autogenerated mock type for the Onfido type
type Onfido struct {
	mock.Mock
}

// CreateApplicant provides a mock function with given fields: firstName, lastName, location
func (_m *Onfido) CreateApplicant(firstName string, lastName string, location bool) (*onfido.CreateApplicantResponse, error) {
	ret := _m.Called(firstName, lastName, location)

	var r0 *onfido.CreateApplicantResponse
	if rf, ok := ret.Get(0).(func(string, string, bool) *onfido.CreateApplicantResponse); ok {
		r0 = rf(firstName, lastName, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*onfido.CreateApplicantResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, bool) error); ok {
		r1 = rf(firstName, lastName, location)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCheck provides a mock function with given fields: applicantId, reportNames
func (_m *Onfido) CreateCheck(applicantId string, reportNames []string) (*onfido.CreateCheckResponse, error) {
	ret := _m.Called(applicantId, reportNames)

	var r0 *onfido.CreateCheckResponse
	if rf, ok := ret.Get(0).(func(string, []string) *onfido.CreateCheckResponse); ok {
		r0 = rf(applicantId, reportNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*onfido.CreateCheckResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []string) error); ok {
		r1 = rf(applicantId, reportNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DownloadDocument provides a mock function with given fields: documentId, destPath
func (_m *Onfido) DownloadDocument(documentId string, destPath string) error {
	ret := _m.Called(documentId, destPath)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(documentId, destPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RetriveReport provides a mock function with given fields: reportId
func (_m *Onfido) RetriveReport(reportId string) (*onfido.ReportResponse, error) {
	ret := _m.Called(reportId)

	var r0 *onfido.ReportResponse
	if rf, ok := ret.Get(0).(func(string) *onfido.ReportResponse); ok {
		r0 = rf(reportId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*onfido.ReportResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(reportId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadDocument provides a mock function with given fields: applicantId, fileType, filePath, side
func (_m *Onfido) UploadDocument(applicantId string, fileType string, filePath string, side string) (*onfido.UploadDocumentResponse, error) {
	ret := _m.Called(applicantId, fileType, filePath, side)

	var r0 *onfido.UploadDocumentResponse
	if rf, ok := ret.Get(0).(func(string, string, string, string) *onfido.UploadDocumentResponse); ok {
		r0 = rf(applicantId, fileType, filePath, side)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*onfido.UploadDocumentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(applicantId, fileType, filePath, side)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewOnfido interface {
	mock.TestingT
	Cleanup(func())
}

// NewOnfido creates a new instance of Onfido. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewOnfido(t mockConstructorTestingTNewOnfido) *Onfido {
	mock := &Onfido{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
